<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS:GO Gun Sim</title>
    <!-- Import Map to resolve 'three' inside GLTFLoader -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* HUD Elements */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0px;
            height: 0px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }
        
        .ch-line {
            position: absolute;
            background-color: #00ff00;
            box-shadow: 0 0 2px #000;
            transition: all 0.05s ease-out;
        }
        
        .ch-top { width: 2px; height: 10px; top: -14px; left: -1px; }
        .ch-bottom { width: 2px; height: 10px; top: 4px; left: -1px; }
        .ch-left { width: 10px; height: 2px; top: -1px; left: -14px; }
        .ch-right { width: 10px; height: 2px; top: -1px; left: 4px; }

        #hud {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 5;
        }

        #ammo-box { display: flex; flex-direction: column; align-items: flex-end; }
        #ammo-count { font-size: 42px; color: #ddd; }
        #ammo-reserve { font-size: 20px; color: #aaa; }
        
        #speed-box {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-family: monospace;
            font-size: 20px;
            z-index: 5;
        }

        #weapon-icon {
            width: 120px;
            height: 40px;
            background: rgba(0,0,0,0.3);
            border: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: #ccc;
            border-radius: 4px;
            text-transform: uppercase;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.85);
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #555;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 10;
        }

        /* Settings Modal */
        #settings-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.95);
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #666;
            color: white;
            z-index: 20;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }

        .menu-btn {
            background: #444; 
            color: white; 
            border: 1px solid #666; 
            padding: 8px 20px;
            font-size: 16px; 
            cursor: pointer; 
            margin-top: 15px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .menu-btn:hover { background: #666; }

        .setting-row { 
            margin: 20px 0; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .setting-row label {
            font-size: 16px;
            color: #ccc;
        }
        input[type=range] { 
            width: 150px; 
            accent-color: #00ff00;
        }

        /* Flashbang Overlay */
        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .key {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #666;
            font-size: 0.9em;
            color: #fff;
            margin: 0 2px;
        }
    </style>
</head>
<body>

    <div id="flash-overlay"></div>

    <!-- HUD -->
    <div id="crosshair">
        <div class="ch-line ch-top" id="ch-top"></div>
        <div class="ch-line ch-bottom" id="ch-bottom"></div>
        <div class="ch-line ch-left" id="ch-left"></div>
        <div class="ch-line ch-right" id="ch-right"></div>
    </div>

    <div id="speed-box">VEL: <span id="vel-display">0</span></div>

    <div id="hud">
        <div id="weapon-icon">AK-47</div>
        <div id="ammo-box">
            <span id="ammo-count">30</span>
            <span id="ammo-reserve">/ 90</span>
        </div>
    </div>

    <!-- Main Menu / Instructions -->
    <div id="instructions">
        <h1 style="margin-top:0;">CS:GO Gun Sim</h1>
        <p>Click Area to Start</p>
        <p><span class="key">WASD</span> Move &nbsp; <span class="key">SPACE</span> Jump (Hold to Bhop)</p>
        <p><span class="key">C</span> Crouch &nbsp; <span class="key">R</span> Reload</p>
        <p><span class="key">1</span> Rifle &nbsp; <span class="key">3</span> Knife &nbsp; <span class="key">4</span> Flash</p>
        <p><span class="key">F (Hold)</span> Inspect &nbsp; <span class="key">L-Click</span> Shoot</p>
        <button id="btn-settings" class="menu-btn">Settings</button>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <h2 style="margin-top:0; color: #fff; border-bottom: 1px solid #444; padding-bottom: 10px;">Audio Settings</h2>
        
        <div class="setting-row">
            <label>Master Volume</label>
            <input type="range" id="vol-master" min="0" max="1" step="0.05" value="1">
        </div>
        
        <div class="setting-row">
            <label>Shoot Volume</label>
            <input type="range" id="vol-shoot" min="0" max="1" step="0.05" value="1">
        </div>
        
        <div class="setting-row">
            <label>Reload Volume</label>
            <input type="range" id="vol-reload" min="0" max="1" step="0.05" value="1">
        </div>

        <button id="btn-back" class="menu-btn">Back</button>
    </div>

    <!-- Three.js from CDN -->
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';

        // --- CONSTANTS ---
        const MAX_SPEED = 6.0;
        const MAX_SPEED_KNIFE = 9.0; 
        const CROUCH_SPEED = 2.25;   
        const CROUCH_SPEED_KNIFE = 3.375; 
        
        // BHOP TUNING
        const MAX_AIR_SPEED = 2.0;    // Increased from 0.8 to allow faster strafe gain
        const ACCEL = 6.5;             
        const AIR_ACCEL = 100.0;       // Increased from 50.0 for sharper air turns
        const FRICTION = 6.0;          
        const STOP_SPEED = 2.0;        
        const GRAVITY = 18.0;          
        const JUMP_FORCE = 6.5;        

        const STAND_HEIGHT = 1.7;
        const CROUCH_HEIGHT = 1.2;

        const SENSITIVITY = 0.002;
        const FIRE_RATE = 100; 
        const MAG_SIZE = 30;
        const RELOAD_TIME = 2000; 
        
        // --- State ---
        let camera, scene, renderer;
        let weaponScene, weaponCamera;

        // Weapon Containers
        let playerHand; 
        let rifleGroup, knifeGroup, flashGroup; // Weapon models
        let muzzleFlashMesh, muzzleLight;

        // Input State
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let keySpace = false, isCrouched = false, canJump = false, isGrounded = false, isLocked = false;
        let velocity = new THREE.Vector3(); 
        let prevTime = performance.now();
        let currentEyeHeight = STAND_HEIGHT;
        
        // Camera Angles
        let camPitch = 0, camYaw = 0;
        let recoilPitch = 0, recoilYaw = 0, recoilScreenShake = 0;

        // Weapon Logic
        let activeWeapon = 'rifle'; 
        let isFiring = false, lastFireTime = 0;
        let currentAmmo = 30, reserveAmmo = 90, isReloading = false, currentSpread = 0;
        
        // Projectiles
        let grenades = [];
        let shells = []; // Array for bullet casings
        let droppedMags = []; // Array for dropped magazines
        let flashIntensity = 0;

        // Animation State
        let weaponBasePos = new THREE.Vector3(0.35, -0.4, -0.7); 
        let knifeBasePos = new THREE.Vector3(0.25, -0.2, -0.45); 
        let flashBasePos = new THREE.Vector3(0.25, -0.3, -0.5); 
        
        let swayPos = new THREE.Vector3(0,0,0);
        let bobTimer = 0;

        // Animation Timers
        let isInspecting = false, inspectTimer = 0, drawTimer = 0; 
        let isInspectHeld = false; 
        let inspectHoldTimer = 0;
        let isSpinning = false;

        let isAttackingKnife = false, knifeAttackTimer = 0;
        let isThrowingFlash = false, flashThrowTimer = 0;

        // Audio
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let gunshotBuffer = null;

        // --- SETTINGS VARIABLES ---
        let volMaster = 1.0;
        let volShoot = 1.0;
        let volReload = 1.0;

        init();
        animate();

        function init() {
            // Load Audio
            fetch('https://freesound.org/data/previews/163/163456_239630-lq.mp3') // Placeholder generic pop
                .then(r => r.arrayBuffer())
                .then(b => audioCtx.decodeAudioData(b))
                .then(a => { gunshotBuffer = a; })
                .catch(() => console.log("Audio load fallback"));

            // 1. MAIN SCENE (World)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 70);

            // 2. WEAPON SCENE (Overlay)
            weaponScene = new THREE.Scene();

            // Main Camera (Moves through world)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 

            // Weapon Camera (Static, renders only gun)
            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.autoClear = false; 
            document.body.appendChild(renderer.domElement);

            // World Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Weapon Lights (Fixed to camera for consistent lighting)
            const weaponAmbient = new THREE.AmbientLight(0xffffff, 0.8);
            weaponScene.add(weaponAmbient);
            const weaponDir = new THREE.DirectionalLight(0xffffff, 0.5);
            weaponDir.position.set(0, 5, 2); 
            weaponScene.add(weaponDir);

            createLevel();
            createPlayerModel();

            // Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            document.addEventListener('mousedown', (e) => { 
                if(isLocked) {
                    if (activeWeapon === 'flash') {
                        if (e.button === 0) startFire('long');
                        if (e.button === 2) startFire('short');
                    } else if (activeWeapon === 'rifle') {
                        if (e.button === 0) startFire();
                    } else {
                        if (e.button === 0) startFire();
                    }
                }
            });
            
            document.addEventListener('mouseup', () => { isFiring = false; });
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('contextmenu', event => event.preventDefault());

            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', (e) => {
                // Prevent starting game if settings button is clicked
                if (e.target.id === 'btn-settings') return;
                document.body.requestPointerLock();
            });

            // --- MENU EVENT LISTENERS ---
            document.getElementById('btn-settings').addEventListener('click', (e) => {
                e.stopPropagation();
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('settings-modal').style.display = 'block';
            });

            document.getElementById('btn-back').addEventListener('click', () => {
                document.getElementById('settings-modal').style.display = 'none';
                document.getElementById('instructions').style.display = 'block';
            });

            // Sliders
            document.getElementById('vol-master').addEventListener('input', (e) => volMaster = parseFloat(e.target.value));
            document.getElementById('vol-shoot').addEventListener('input', (e) => volShoot = parseFloat(e.target.value));
            document.getElementById('vol-reload').addEventListener('input', (e) => volReload = parseFloat(e.target.value));


            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === document.body) {
                    isLocked = true;
                    instructions.style.display = 'none';
                    document.getElementById('settings-modal').style.display = 'none';
                    audioCtx.resume();
                } else {
                    isLocked = false;
                    // If we just exited settings, don't show instructions? 
                    // Simpler logic: if not locked, show instructions unless settings is open
                    if (document.getElementById('settings-modal').style.display === 'none') {
                        instructions.style.display = 'block';
                    }
                    isFiring = false;
                }
            });

            window.addEventListener('resize', onWindowResize);
        }

        function createLevel() {
            const floorGeo = new THREE.PlaneGeometry(100, 100);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xddccaa, roughness: 0.8 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            const wallMat = new THREE.MeshStandardMaterial({ color: 0xccbb99 });
            const createWall = (x, y, z, w, h, d) => {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mesh = new THREE.Mesh(geo, wallMat);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }

            createWall(0, 5, -20, 40, 10, 1);
            createWall(-20, 5, 0, 1, 10, 40);
            createWall(20, 5, 0, 1, 10, 40);
            createWall(0, 5, 20, 40, 10, 1);

            const crateMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const createCrate = (x, z, s) => {
                const geo = new THREE.BoxGeometry(s, s, s);
                const mesh = new THREE.Mesh(geo, crateMat);
                mesh.position.set(x, s/2, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }
            createCrate(0, -10, 2);
            createCrate(5, -15, 3);
            createCrate(-5, -8, 2);
            createCrate(8, 5, 2);
        }

        function createPlayerModel() {
            playerHand = new THREE.Group();
            weaponCamera.add(playerHand);
            weaponScene.add(weaponCamera);

            rifleGroup = createAK47();
            knifeGroup = createM9Bayonet();
            flashGroup = createFlashbang();

            playerHand.add(rifleGroup);
            playerHand.add(knifeGroup);
            playerHand.add(flashGroup);

            // FIX: Reset activeWeapon to null before first switch.
            // This forces switchWeapon('rifle') to run fully, hiding the knife/flashbang 
            // which otherwise default to visible and obstruct the camera.
            activeWeapon = null; 
            switchWeapon('rifle');
        }

        function createAK47() {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6 }); 

            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.4), metalMat);
            group.add(body);
            // Stock
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.12, 0.3), woodMat);
            stock.position.set(0, -0.02, 0.35);
            stock.rotation.x = -0.1;
            group.add(stock);
            // Barrel
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.6, 8), metalMat);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.02, -0.5);
            group.add(barrel);
            // Guard
            const guard = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.08, 0.3), woodMat);
            guard.position.set(0, 0, -0.35);
            group.add(guard);
            // Mag
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.25, 0.1), metalMat);
            mag.position.set(0, -0.15, -0.1);
            mag.rotation.x = 0.3;
            mag.name = "magazine"; 
            group.add(mag);

            // Hands
            const rHand = new THREE.Group();
            rHand.position.set(0, -0.12, 0.25);
            rHand.rotation.x = -0.2;
            const rPalm = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.09, 0.05), skinMat);
            rHand.add(rPalm);
            const rIndex = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.07, 8), skinMat);
            rIndex.position.set(0.02, 0.03, -0.03);
            rIndex.rotation.set(0.5, 0, 0);
            rHand.add(rIndex);
            const rArm = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.04, 0.7, 16), skinMat);
            rArm.position.set(0.25, -0.4, 0.65);
            rArm.lookAt(rHand.position);
            rArm.rotateX(-Math.PI / 2);
            rArm.position.add(new THREE.Vector3(0, -0.05, 0));
            group.add(rHand);
            group.add(rArm);

            const lHand = new THREE.Group();
            lHand.position.set(0, -0.06, -0.35);
            const lPalm = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.025, 0.07), skinMat);
            lPalm.position.y = -0.02;
            lHand.add(lPalm);
            const lThumb = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.07, 8), skinMat);
            lThumb.position.set(0.04, 0.01, -0.01);
            lThumb.rotation.set(0.2, -0.3, 1.2);
            lHand.add(lThumb);
            for(let i=0; i<4; i++) {
                const f = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.08, 8), skinMat);
                f.position.set(-0.04, 0.01, 0.025 - (i * 0.018));
                f.rotation.set(0, 0, -1.0);
                lHand.add(f);
            }
            const lArm = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.04, 1.2, 16), skinMat);
            lArm.position.set(-0.3, -0.45, 0.1);
            lArm.lookAt(lHand.position);
            lArm.rotateX(-Math.PI / 2);
            group.add(lHand);
            group.add(lArm);

            // --- IMPROVED MUZZLE FLASH ---
            muzzleFlashMesh = new THREE.Group();
            muzzleFlashMesh.position.set(0, 0.02, -0.9);
            muzzleFlashMesh.visible = false;
            group.add(muzzleFlashMesh);

            const flashMat = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                transparent: true, 
                opacity: 0.8, 
                side: THREE.DoubleSide, 
                blending: THREE.AdditiveBlending,
                depthWrite: false // Prevents transparency issues
            });
            
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.9, 
                side: THREE.DoubleSide, 
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            // 1. Cross Planes (Outer Flame)
            const plane1 = new THREE.Mesh(new THREE.PlaneGeometry(0.35, 0.12), flashMat);
            muzzleFlashMesh.add(plane1);
            
            const plane2 = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 0.35), flashMat);
            muzzleFlashMesh.add(plane2);

            // 2. Central Core (Bright Hotspot)
            const core = new THREE.Mesh(new THREE.CircleGeometry(0.06, 8), coreMat);
            core.position.z = 0.01; // Slight offset to prevent z-fighting
            muzzleFlashMesh.add(core);

            // Light
            muzzleLight = new THREE.PointLight(0xffaa00, 0, 10);
            muzzleLight.position.set(0, 0.05, -1.0);
            group.add(muzzleLight);

            return group;
        }

        function createM9Bayonet() {
            const group = new THREE.Group();
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.2 }); 
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
            const guardMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6 });

            const weaponWrapper = new THREE.Group();
            weaponWrapper.rotation.set(0, 0, -0.2); 
            
            const handleGeo = new THREE.CylinderGeometry(0.022, 0.025, 0.13, 12);
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = 0.01;
            handle.scale.set(1, 1, 0.8);
            weaponWrapper.add(handle);

            const pommel = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.022, 0.02, 12), guardMat);
            pommel.position.y = -0.065;
            weaponWrapper.add(pommel);

            const guard = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.06, 0.02), guardMat);
            guard.position.y = 0.08;
            weaponWrapper.add(guard);
            
            const bladeGeo = new THREE.BoxGeometry(0.006, 0.25, 0.035);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.215; 
            
            const positions = blade.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                if (y > 0) positions[i] *= (1 - (y / 0.15) * 0.5);
                if (positions[i+2] < 0) positions[i+2] *= 0.1;
            }
            blade.geometry.attributes.position.needsUpdate = true;
            weaponWrapper.add(blade);
            group.add(weaponWrapper);

            const handGroup = new THREE.Group();
            const palm = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.05), skinMat);
            palm.position.set(0.03, 0, 0); 
            handGroup.add(palm);

            const f1 = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.09, 8), skinMat);
            f1.rotation.z = Math.PI / 2;
            f1.position.set(0.03, 0.04, 0.035);
            f1.rotation.x = 0.2;
            handGroup.add(f1);
            
            const f2 = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.095, 8), skinMat);
            f2.rotation.z = Math.PI / 2;
            f2.position.set(0.03, 0.015, 0.035);
            f2.rotation.x = 0.1;
            handGroup.add(f2);

            const f3 = new THREE.Mesh(new THREE.CylinderGeometry(0.011, 0.011, 0.09, 8), skinMat);
            f3.rotation.z = Math.PI / 2;
            f3.position.set(0.03, -0.01, 0.035);
            handGroup.add(f3);

            const f4 = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.075, 8), skinMat);
            f4.rotation.z = Math.PI / 2;
            f4.position.set(0.03, -0.035, 0.035);
            f4.rotation.x = -0.1;
            handGroup.add(f4);

            const thumb = new THREE.Mesh(new THREE.CylinderGeometry(0.013, 0.013, 0.07, 8), skinMat);
            thumb.position.set(0.04, 0.03, -0.03);
            thumb.rotation.set(0.5, 0.5, 0);
            handGroup.add(thumb);

            group.add(handGroup);
            group.rotation.set(0, 0, 0); 
            return group;
        }

        function createFlashbang() {
            const group = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.4, metalness: 0.5 });
            const topMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            const stripMat = new THREE.MeshStandardMaterial({ color: 0x00ccff, roughness: 0.8 }); 
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6 });

            const grenade = new THREE.Group();
            
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.12, 16), bodyMat);
            grenade.add(body);

            const strip = new THREE.Mesh(new THREE.CylinderGeometry(0.031, 0.031, 0.02, 16), stripMat);
            strip.position.y = 0.03;
            grenade.add(strip);

            const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.025, 0.03, 12), topMat);
            fuse.position.y = 0.075;
            grenade.add(fuse);

            const spoon = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.1, 0.02), topMat);
            spoon.position.set(0.02, 0.05, 0);
            spoon.rotation.z = -0.1;
            grenade.add(spoon);

            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.01, 0.002, 8, 16), new THREE.MeshStandardMaterial({color:0xcccccc}));
            ring.position.set(-0.01, 0.08, 0);
            grenade.add(ring);

            grenade.rotation.x = Math.PI / 2; 
            grenade.position.y = 0.03;
            group.add(grenade);

            const hand = new THREE.Group();
            const palm = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.09, 0.05), skinMat);
            hand.add(palm);
            
            const thumb = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.06, 8), skinMat);
            thumb.position.set(0.03, 0.04, 0);
            thumb.rotation.z = 1.0;
            hand.add(thumb);

            for(let i=0; i<4; i++) {
                const f = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.08, 8), skinMat);
                f.position.set(-0.03, 0.03 - (i*0.02), 0.03);
                f.rotation.x = 1.5;
                f.rotation.z = -0.5;
                hand.add(f);
            }

            hand.position.set(0, -0.05, 0);
            group.add(hand);

            return group;
        }

        function switchWeapon(type) {
            if (activeWeapon === type || isReloading || isAttackingKnife || isThrowingFlash) return;
            
            isInspecting = false;
            inspectTimer = 0;
            isFiring = false;
            isInspectHeld = false; 
            isSpinning = false;
            inspectHoldTimer = 0;
            
            activeWeapon = type;
            drawTimer = 0; 

            rifleGroup.visible = false;
            knifeGroup.visible = false;
            flashGroup.visible = false;

            if (type === 'rifle') {
                rifleGroup.visible = true;
                document.getElementById('weapon-icon').innerText = "AK-47";
                document.getElementById('ammo-box').style.opacity = "1";
                document.querySelectorAll('.ch-line').forEach(el => el.style.backgroundColor = '#00ff00');
            } else if (type === 'knife') {
                knifeGroup.visible = true;
                document.getElementById('weapon-icon').innerText = "M9 BAYONET";
                document.getElementById('ammo-box').style.opacity = "0.3"; 
                document.querySelectorAll('.ch-line').forEach(el => el.style.backgroundColor = 'rgba(255, 255, 255, 0.3)');
            } else if (type === 'flash') {
                flashGroup.visible = true;
                document.getElementById('weapon-icon').innerText = "FLASHBANG";
                document.getElementById('ammo-box').style.opacity = "0.3"; 
                document.querySelectorAll('.ch-line').forEach(el => el.style.backgroundColor = 'rgba(255, 255, 255, 0.3)');
            }
        }

        function startFire(mode = 'long') {
            if (isInspecting) isInspecting = false;
            if (activeWeapon === 'rifle') isFiring = true;
            else if (activeWeapon === 'knife') stab();
            else if (activeWeapon === 'flash') throwFlash(mode);
        }

        function stab() {
            if (isAttackingKnife || drawTimer < 0.8) return;
            isAttackingKnife = true;
            knifeAttackTimer = 0;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = 2.5; 
            const intersects = raycaster.intersectObjects(scene.children);
            playSound('swish');

            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.object.geometry.type !== 'PlaneGeometry' || hit.distance < 2.0) {
                     setTimeout(() => {
                        createBulletHole(hit.point, hit.face.normal, true);
                        playSound('stab_hit');
                     }, 150);
                }
            }
        }

        function throwFlash(mode) {
            if (isThrowingFlash || drawTimer < 0.8) return;
            isThrowingFlash = true;
            flashThrowTimer = 0;
            
            setTimeout(() => {
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                
                let speed = 25.0; 
                let lift = 4.0;   
                
                if (mode === 'short') {
                    speed = 8.0; 
                    lift = 2.5;
                }

                const spawnPos = camera.position.clone().add(dir.clone().multiplyScalar(0.5));
                const vel = dir.clone().multiplyScalar(speed).add(velocity); 
                vel.y += lift; 

                const grenadeObj = {
                    mesh: new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({color:0xdddddd})),
                    velocity: vel,
                    life: 2.0 
                };
                grenadeObj.mesh.position.copy(spawnPos);
                scene.add(grenadeObj.mesh);
                grenades.push(grenadeObj);
                
                playSound('throw');
            }, 300);
        }

        function getVolume(type) {
            let v = volMaster;
            if (type === 'shoot') v *= volShoot;
            // Reload sounds group
            if (['mag_out', 'mag_in', 'rack', 'shell_eject'].includes(type)) v *= volReload;
            return v;
        }

        function playSound(type, intensity = 1.0) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const t = audioCtx.currentTime;
            
            // Get multplier
            const vol = getVolume(type);

            // FIX: If volume is effectively zero, simply return to avoid playing empty sounds and 
            // causing exponentialRamp errors with 0 values.
            if (vol <= 0.0001) return;

            if (type === 'shoot') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(20, t + 0.1);
                
                // Apply vol
                gain.gain.setValueAtTime(0.5 * vol, t);
                gain.gain.exponentialRampToValueAtTime(0.01 * vol, t + 0.15);
                
                osc.start(t);
                osc.stop(t + 0.2);
                
                const noiseSize = audioCtx.sampleRate * 0.2;
                const buffer = audioCtx.createBuffer(1, noiseSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < noiseSize; i++) data[i] = Math.random() * 2 - 1;
                const noiseSrc = audioCtx.createBufferSource();
                noiseSrc.buffer = buffer;
                const noiseGain = audioCtx.createGain();
                noiseSrc.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                
                // Apply vol
                noiseGain.gain.setValueAtTime(0.5 * vol, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01 * vol, t + 0.2);
                
                noiseSrc.start(t);

            } else if (type === 'swish') {
                const bufferSize = audioCtx.sampleRate * 0.3;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.Q.value = 0.5;
                filter.frequency.setValueAtTime(600, t);
                filter.frequency.linearRampToValueAtTime(3000, t + 0.1);
                filter.frequency.linearRampToValueAtTime(600, t + 0.25); 
                const gain = audioCtx.createGain();
                
                gain.gain.setValueAtTime(0.01 * vol, t);
                gain.gain.linearRampToValueAtTime(0.6 * vol, t + 0.08); 
                gain.gain.exponentialRampToValueAtTime(0.01 * vol, t + 0.25); 
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(t);
                noise.stop(t + 0.3);

            } else if (type === 'stab_hit') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(40, t + 0.05);
                
                gain.gain.setValueAtTime(0.5 * vol, t);
                gain.gain.exponentialRampToValueAtTime(0.01 * vol, t + 0.05);
                
                osc.start(t);
                osc.stop(t + 0.1);
            } else if (type === 'throw') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.linearRampToValueAtTime(200, t + 0.1);
                
                gain.gain.setValueAtTime(0.2 * vol, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.1);
                
                osc.start(t);
                osc.stop(t + 0.15);
            } else if (type === 'bang') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(2500, t);
                
                gain.gain.setValueAtTime(0.3 * intensity * vol, t);
                gain.gain.exponentialRampToValueAtTime(0.01 * vol, t + 2.0);
                
                osc.start(t);
                osc.stop(t + 2.5);

                const noiseSize = audioCtx.sampleRate * 0.5;
                const buffer = audioCtx.createBuffer(1, noiseSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < noiseSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const ng = audioCtx.createGain();
                noise.connect(ng);
                ng.connect(audioCtx.destination);
                
                ng.gain.setValueAtTime(1.0 * intensity * vol, t);
                ng.gain.exponentialRampToValueAtTime(0.01 * vol, t + 0.5);
                
                noise.start(t);
            } 
            // NEW SOUNDS
            else if (type === 'mag_out') {
                // Clicking/Sliding Sound
                const bufferSize = audioCtx.sampleRate * 0.3;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                const gain = audioCtx.createGain();
                
                gain.gain.setValueAtTime(0.5 * vol, t);
                gain.gain.exponentialRampToValueAtTime(0.01 * vol, t + 0.2);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(t);
            } else if (type === 'mag_in') {
                // Heavier Thud/Click
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
                
                gain.gain.setValueAtTime(0.4 * vol, t);
                gain.gain.exponentialRampToValueAtTime(0.01 * vol, t + 0.1);
                
                osc.start(t);
                osc.stop(t + 0.1);

                const bufferSize = audioCtx.sampleRate * 0.2;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 600;
                const nGain = audioCtx.createGain();
                
                nGain.gain.setValueAtTime(0.6 * vol, t);
                nGain.gain.exponentialRampToValueAtTime(0.01 * vol, t + 0.15);
                
                noise.connect(filter);
                filter.connect(nGain);
                nGain.connect(audioCtx.destination);
                noise.start(t);

            } else if (type === 'rack') {
                // Metallic Slide
                const bufferSize = audioCtx.sampleRate * 0.4;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.Q.value = 5.0; // Resonant
                filter.frequency.setValueAtTime(1200, t);
                filter.frequency.linearRampToValueAtTime(2000, t + 0.1);
                filter.frequency.linearRampToValueAtTime(1000, t + 0.2);

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.01 * vol, t);
                gain.gain.linearRampToValueAtTime(0.4 * vol, t + 0.05);
                gain.gain.linearRampToValueAtTime(0.01 * vol, t + 0.3);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(t);

                // Add a "clank"
                const osc = audioCtx.createOscillator();
                const oscGain = audioCtx.createGain();
                osc.connect(oscGain);
                oscGain.connect(audioCtx.destination);
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, t + 0.1);
                oscGain.gain.setValueAtTime(0, t);
                oscGain.gain.setValueAtTime(0.3 * vol, t + 0.1);
                oscGain.gain.exponentialRampToValueAtTime(0.01 * vol, t + 0.3);
                osc.start(t);
                osc.stop(t+0.4);

            } else if (type === 'shell_eject') {
                // High-pitched tink
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                // Randomize pitch slightly
                const freq = 1800 + Math.random() * 400;
                osc.frequency.setValueAtTime(freq, t);
                
                gain.gain.setValueAtTime(0.05 * intensity * vol, t); // Quiet
                gain.gain.exponentialRampToValueAtTime(0.001 * vol, t + 0.1);
                
                osc.start(t);
                osc.stop(t + 0.15);
            }
        }

        function onKeyDown(event) {
            if (event.repeat) return;
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyR': if(activeWeapon === 'rifle') reload(); break;
                case 'KeyC': isCrouched = true; break; 
                case 'Digit1': switchWeapon('rifle'); break;
                case 'Digit3': switchWeapon('knife'); break;
                case 'Digit4': switchWeapon('flash'); break;
                case 'KeyF': 
                    if (activeWeapon === 'knife') {
                        isInspectHeld = true;
                        
                        // Always restart the inspect from beginning on press
                        isInspecting = true;
                        inspectTimer = 0;
                        inspectHoldTimer = 0;
                        isSpinning = false;
                        if (knifeGroup) knifeGroup.rotation.set(0, 0, 0);
                    } 
                    else if(!isReloading && !isFiring) {
                        isInspecting = true; 
                        inspectTimer = 0; 
                    }
                    break;
                case 'Space': keySpace = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyC': isCrouched = false; break;
                case 'KeyF': 
                    isInspectHeld = false; 
                    if (activeWeapon === 'knife' && isSpinning) {
                        isInspecting = false;
                        isSpinning = false;
                    }
                    break; 
                case 'Space': keySpace = false; break;
            }
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            weaponCamera.aspect = width / height;
            weaponCamera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        function onMouseMove(event) {
            if (!isLocked) return;
            if (Math.abs(event.movementX) > 100 || Math.abs(event.movementY) > 100) return;

            camYaw -= event.movementX * SENSITIVITY;
            camPitch -= event.movementY * SENSITIVITY;
            
            const limit = 1.51; 
            if (camPitch > limit) camPitch = limit;
            if (camPitch < -limit) camPitch = -limit;
            
            const maxSway = 0.06;
            const swayX = Math.max(-maxSway, Math.min(maxSway, -event.movementX * 0.0006));
            const swayY = Math.max(-maxSway, Math.min(maxSway, -event.movementY * 0.0006));
            swayPos.x = swayX;
            swayPos.y = swayY;
        }

        function fireRifle() {
            if (isReloading || isInspecting) return;
            
            // REMOVED AUTO RELOAD: Just stop firing if empty
            if (currentAmmo <= 0) { 
                isFiring = false; 
                return; 
            }

            currentAmmo--;
            updateHUD();
            
            // Check if magazine needs to drop immediately
            if (currentAmmo === 0) {
                dropMagazine();
            }
            
            playSound('shoot');

            let kickUp = 0.11 + Math.random() * 0.06; 
            let kickSide = (Math.random() - 0.5) * 0.1;
            
            // Increased standing recoil multiplier from 1.0 to 2.0
            const recoilMod = isCrouched ? 0.3 : 2.0;
            kickUp *= recoilMod;
            kickSide *= recoilMod;

            recoilPitch += kickUp;
            recoilYaw += kickSide;
            recoilScreenShake = (Math.random() - 0.5) * 0.08 * recoilMod;

            rifleGroup.position.z += 0.25; 
            rifleGroup.rotation.x += 0.2;   

            // Flash Logic
            muzzleFlashMesh.visible = true;
            muzzleFlashMesh.rotation.z = Math.random() * Math.PI * 2; // Random rotation
            
            const scale = 0.8 + Math.random() * 0.6; // Random size
            muzzleFlashMesh.scale.set(scale, scale, 1);
            
            muzzleLight.intensity = 5.0;
            
            // Eject Shell
            ejectShell();

            setTimeout(() => { muzzleFlashMesh.visible = false; }, 40);

            const horizSpeed = new THREE.Vector2(velocity.x, velocity.z).length();
            let spreadFactor = 0.008; 
            if (horizSpeed > 0.1) spreadFactor += (horizSpeed / MAX_SPEED) * 0.15;
            if (!isGrounded) spreadFactor += 0.1;
            if (isCrouched) {
                if (horizSpeed < 0.1) spreadFactor = 0.0005; 
                else spreadFactor *= 0.4;
            }
            currentSpread = spreadFactor * 50.0; 

            const spreadX = (Math.random() - 0.5) * spreadFactor;
            const spreadY = (Math.random() - 0.5) * spreadFactor;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(spreadX, spreadY), camera);

            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.object !== muzzleFlashMesh && !playerHand.children.includes(hit.object)) {
                    createBulletHole(hit.point, hit.face.normal);
                }
            }
        }
        
        function dropMagazine() {
            const mag = rifleGroup.getObjectByName('magazine');
            if (!mag || !mag.visible) return;
            
            mag.visible = false;
            
            // Create world mag physics object
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
            const worldMag = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.25, 0.1), metalMat);
            
            // Position: Offset relative to camera + Camera Position
            const offset = new THREE.Vector3();
            mag.getWorldPosition(offset); // Get position in weapon scene (relative to camera view origin)
            
            offset.applyQuaternion(camera.quaternion); // Orient offset to world view
            worldMag.position.copy(camera.position).add(offset);
            
            // Rotation: Combined camera rotation + mag local rotation
            const rotation = new THREE.Quaternion();
            mag.getWorldQuaternion(rotation);
            const finalQuat = camera.quaternion.clone().multiply(rotation);
            worldMag.quaternion.copy(finalQuat);
            
            scene.add(worldMag);
            
            const vel = velocity.clone();
            vel.y -= 1.0; // Drop down
            
            droppedMags.push({
                mesh: worldMag,
                velocity: vel,
                rotVel: new THREE.Vector3(Math.random(), Math.random(), Math.random()),
                life: 10.0
            });
        }

        function ejectShell() {
            // Create Shell Geometry
            const shellGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.04, 6);
            const shellMat = new THREE.MeshStandardMaterial({ color: 0xD4AF37, metalness: 0.8, roughness: 0.3 }); // Gold color
            const shell = new THREE.Mesh(shellGeo, shellMat);
            
            // Calculate Spawn Position (Approximation relative to camera/weapon)
            // Rifle is roughly at local (0.35, -0.4, -0.7) relative to camera
            // Ejection port is on the right side of the gun
            
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

            // Base position relative to camera
            const spawnPos = camera.position.clone()
                .add(right.clone().multiplyScalar(0.35)) // Right offset
                .add(up.clone().multiplyScalar(-0.25))   // Height offset
                .add(forward.clone().multiplyScalar(0.5)); // Forward offset
                
            shell.position.copy(spawnPos);
            shell.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            
            scene.add(shell);

            // Calculate Velocity
            // Eject to the LEFT (negative right) and slightly up/back
            const ejectDir = right.clone().multiplyScalar(-(2.0 + Math.random()))
                .add(up.clone().multiplyScalar(1.5 + Math.random() * 0.5))
                .add(forward.clone().multiplyScalar(-0.5 + Math.random() * 0.5));
            
            // Add player velocity so shells carry momentum
            ejectDir.add(velocity);

            shells.push({
                mesh: shell,
                velocity: ejectDir,
                rotVel: new THREE.Vector3(Math.random()*10, Math.random()*10, Math.random()*10),
                life: 3.0,
                bounced: false
            });
        }

        function createBulletHole(position, normal, isKnife = false) {
            const size = isKnife ? 0.15 : 0.1;
            const decal = new THREE.Mesh(
                new THREE.PlaneGeometry(size, size),
                new THREE.MeshBasicMaterial({ color: isKnife ? 0x333333 : 0x111111, side: THREE.DoubleSide })
            );
            decal.position.copy(position).add(normal.clone().multiplyScalar(0.01));
            decal.lookAt(position.clone().add(normal));
            if(isKnife) decal.rotation.z = Math.random() * Math.PI; 
            scene.add(decal);
            setTimeout(() => { scene.remove(decal); }, 10000);
        }

        function reload() {
            if (isReloading || currentAmmo === MAG_SIZE || reserveAmmo <= 0) return;
            
            // Check if we are starting from an empty/dropped mag state
            const isEmptyStart = (currentAmmo === 0);
            
            isReloading = true;
            isInspecting = false;
            
            const mag = rifleGroup.getObjectByName('magazine');
            const initialMagPos = new THREE.Vector3(0, -0.15, -0.1);
            
            // Positions for the animation steps
            const droppedMagPos = new THREE.Vector3(0.2, -0.8, -0.1); // Drop far down and right
            const newMagStartPos = new THREE.Vector3(-0.2, -0.8, 0.1); // Come from bottom left
            
            let startTime = performance.now();
            
            // If empty, reload is faster because we skip taking the old mag out
            // Reduced from 1040 to 832 (Another 1.25x faster)
            const duration = isEmptyStart ? 832 : RELOAD_TIME;
            
            // Track sound triggers
            let playedMagOut = false;
            let playedMagIn = false;
            let playedRack = false;
            
            const animateReload = () => {
                const now = performance.now();
                const progress = (now - startTime) / duration;
                
                if (isEmptyStart) {
                    // --- FAST RELOAD (Empty) ---
                    // Timeline: Tilt -> Insert -> Rack -> Recover
                    
                    // 1. TILT (0% - 25%)
                    if (progress < 0.25) {
                        const t = progress / 0.25;
                        const ease = 1 - Math.pow(1 - t, 3);
                        
                        rifleGroup.rotation.z = THREE.MathUtils.lerp(0, 0.6, ease);
                        rifleGroup.rotation.x = THREE.MathUtils.lerp(0, 0.3, ease);
                        rifleGroup.rotation.y = THREE.MathUtils.lerp(0, -0.2, ease);
                        rifleGroup.position.y = THREE.MathUtils.lerp(weaponBasePos.y, weaponBasePos.y + 0.05, ease);
                        
                        // Ensure mag stays hidden (it was dropped)
                        if (progress < 0.1) mag.visible = false;
                    }
                    
                    // 2. MAG IN (25% - 60%) - Skip removal, go straight to insert
                    else if (progress < 0.60) {
                        const t = (progress - 0.25) / 0.35;
                        const ease = 1 - Math.pow(1 - t, 2);
                        
                        // On start of this phase, make mag visible and snap to start pos
                        if (t < 0.1) {
                             mag.visible = true; 
                             mag.rotation.set(0.3, 0, 0);
                        }

                        mag.position.lerpVectors(newMagStartPos, initialMagPos, ease);
                        
                        if (t > 0.85 && !playedMagIn) {
                            playSound('mag_in');
                            playedMagIn = true;
                            recoilScreenShake += 0.015; 
                            rifleGroup.position.y += 0.02; 
                            rifleGroup.rotation.x -= 0.05; 
                        }
                    }
                    
                    // 3. RACK (60% - 85%)
                    else if (progress < 0.85) {
                        const t = (progress - 0.60) / 0.25;
                        mag.position.copy(initialMagPos); // Lock mag
                        
                        if (t > 0.1 && !playedRack) {
                            playSound('rack');
                            playedRack = true;
                            recoilScreenShake += 0.025; 
                        }

                        let rackOffset = 0;
                        if (t < 0.5) rackOffset = t * 2;
                        else rackOffset = 1 - ((t - 0.5) * 2);
                        
                        rifleGroup.position.z = weaponBasePos.z + (rackOffset * 0.15); 
                        rifleGroup.rotation.x = 0.3 - (rackOffset * 0.1);
                        rifleGroup.rotation.z = 0.6 + (Math.random() * 0.02);
                    }
                    
                    // 4. RECOVER (85% - 100%)
                    else {
                        const t = (progress - 0.85) / 0.15;
                        rifleGroup.rotation.z = THREE.MathUtils.lerp(0.6, 0, t);
                        rifleGroup.rotation.x = THREE.MathUtils.lerp(0.3, 0, t);
                        rifleGroup.rotation.y = THREE.MathUtils.lerp(-0.2, 0, t);
                        rifleGroup.position.y = THREE.MathUtils.lerp(weaponBasePos.y + 0.05, weaponBasePos.y, t);
                        rifleGroup.position.z = THREE.MathUtils.lerp(weaponBasePos.z, weaponBasePos.z, t);
                    }

                } else {
                    // --- NORMAL RELOAD (Standard) ---
                    
                    // 1. TILT (0% - 20%)
                    if (progress < 0.2) {
                        const t = progress / 0.2;
                        const ease = 1 - Math.pow(1 - t, 3);
                        rifleGroup.rotation.z = THREE.MathUtils.lerp(0, 0.6, ease);
                        rifleGroup.rotation.x = THREE.MathUtils.lerp(0, 0.3, ease);
                        rifleGroup.rotation.y = THREE.MathUtils.lerp(0, -0.2, ease);
                        rifleGroup.position.y = THREE.MathUtils.lerp(weaponBasePos.y, weaponBasePos.y + 0.05, ease);
                        // Ensure visible if standard reload
                        if (progress < 0.05) mag.visible = true;
                    }
                    // 2. MAG OUT (20% - 45%)
                    else if (progress < 0.45) {
                        const t = (progress - 0.2) / 0.25;
                        const dropT = t * t;
                        if (!playedMagOut) { playSound('mag_out'); playedMagOut = true; }
                        mag.position.lerpVectors(initialMagPos, droppedMagPos, dropT);
                        mag.rotation.z = THREE.MathUtils.lerp(0.3, 1.5, t);
                        mag.rotation.x = THREE.MathUtils.lerp(0, 0.5, t);
                        rifleGroup.position.y = weaponBasePos.y + 0.05 + (Math.sin(t * Math.PI) * 0.005);
                    }
                    // 3. MAG IN (45% - 70%)
                    else if (progress < 0.70) {
                        const t = (progress - 0.45) / 0.25;
                        const ease = 1 - Math.pow(1 - t, 2);
                        if (t < 0.1) mag.rotation.set(0.3, 0, 0);
                        mag.position.lerpVectors(newMagStartPos, initialMagPos, ease);
                        if (t > 0.85 && !playedMagIn) {
                            playSound('mag_in'); playedMagIn = true;
                            recoilScreenShake += 0.015; rifleGroup.position.y += 0.02; rifleGroup.rotation.x -= 0.05; 
                        }
                    }
                    // 4. RACK (70% - 90%)
                    else if (progress < 0.90) {
                        const t = (progress - 0.70) / 0.20;
                        mag.position.copy(initialMagPos);
                        if (t > 0.1 && !playedRack) {
                            playSound('rack'); playedRack = true; recoilScreenShake += 0.025; 
                        }
                        let rackOffset = (t < 0.5) ? t * 2 : 1 - ((t - 0.5) * 2);
                        rifleGroup.position.z = weaponBasePos.z + (rackOffset * 0.15); 
                        rifleGroup.rotation.x = 0.3 - (rackOffset * 0.1);
                        rifleGroup.rotation.z = 0.6 + (Math.random() * 0.02);
                    }
                    // 5. RECOVER (90% - 100%)
                    else {
                        const t = (progress - 0.90) / 0.10;
                        rifleGroup.rotation.z = THREE.MathUtils.lerp(0.6, 0, t);
                        rifleGroup.rotation.x = THREE.MathUtils.lerp(0.3, 0, t);
                        rifleGroup.rotation.y = THREE.MathUtils.lerp(-0.2, 0, t);
                        rifleGroup.position.y = THREE.MathUtils.lerp(weaponBasePos.y + 0.05, weaponBasePos.y, t);
                        rifleGroup.position.z = THREE.MathUtils.lerp(weaponBasePos.z, weaponBasePos.z, t);
                    }
                }

                if (progress < 1) {
                    requestAnimationFrame(animateReload);
                } else {
                    // COMPLETE: Reset everything strictly
                    rifleGroup.rotation.set(0, 0, 0);
                    rifleGroup.position.copy(weaponBasePos);
                    mag.position.copy(initialMagPos); 
                    mag.rotation.set(0.3, 0, 0); 
                    mag.visible = true; // Ensure visible after complete
                    
                    const needed = MAG_SIZE - currentAmmo;
                    const toAdd = Math.min(needed, reserveAmmo);
                    currentAmmo += toAdd;
                    reserveAmmo -= toAdd;
                    isReloading = false;
                    updateHUD();
                }
            };
            animateReload();
        }

        function updateHUD() {
            if (activeWeapon === 'flash') {
                document.getElementById('ammo-count').innerText = "--";
                document.getElementById('ammo-reserve').innerText = "";
            } else {
                document.getElementById('ammo-count').innerText = currentAmmo;
                document.getElementById('ammo-reserve').innerText = "/ " + reserveAmmo;
            }
        }

        function updateCrosshair(vel) {
            if (activeWeapon === 'knife' || activeWeapon === 'flash') {
                const top = document.getElementById('ch-top');
                const bot = document.getElementById('ch-bottom');
                const left = document.getElementById('ch-left');
                const right = document.getElementById('ch-right');
                top.style.top = `-8px`; bot.style.top = `2px`;
                left.style.left = `-8px`; right.style.left = `2px`;
                return;
            }

            const speed = new THREE.Vector2(vel.x, vel.z).length();
            let gap = 5;
            if (speed > 0.1) gap += (speed / MAX_SPEED) * 50; 
            if (!isGrounded) gap += 30; 
            gap += currentSpread; 
            gap = Math.min(gap, 100);

            const top = document.getElementById('ch-top');
            const bot = document.getElementById('ch-bottom');
            const left = document.getElementById('ch-left');
            const right = document.getElementById('ch-right');

            top.style.top = `-${14 + gap}px`;
            bot.style.top = `${4 + gap}px`;
            left.style.left = `-${14 + gap}px`;
            right.style.left = `${4 + gap}px`;
        }

        function applyFriction(delta) {
            const speed = new THREE.Vector2(velocity.x, velocity.z).length();
            if (speed < 0.1) return;
            const control = (speed < STOP_SPEED) ? STOP_SPEED : speed;
            const drop = control * FRICTION * delta;
            let newSpeed = speed - drop;
            if (newSpeed < 0) newSpeed = 0;
            if (newSpeed !== speed) {
                newSpeed /= speed;
                velocity.x *= newSpeed;
                velocity.z *= newSpeed;
            }
        }

        function accelerate(wishDir, wishSpeed, accel, delta) {
            const currentSpeed = (velocity.x * wishDir.x) + (velocity.z * wishDir.z);
            const addSpeed = wishSpeed - currentSpeed;
            if (addSpeed <= 0) return;
            let accelSpeed = accel * delta * wishSpeed;
            if (accelSpeed > addSpeed) accelSpeed = addSpeed;
            velocity.x += accelSpeed * wishDir.x;
            velocity.z += accelSpeed * wishDir.z;
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);
            prevTime = time;

            if (!isLocked) {
                renderer.render(scene, camera);
                return;
            }

            // --- RENDER PASS (Clear -> World -> ClearDepth -> Weapon) ---
            renderer.clear();
            renderer.render(scene, camera);
            renderer.clearDepth();
            renderer.render(weaponScene, weaponCamera);

            // --- Shell Physics ---
            for (let i = shells.length - 1; i >= 0; i--) {
                const s = shells[i];
                s.life -= delta;
                s.velocity.y -= GRAVITY * delta;
                s.mesh.position.add(s.velocity.clone().multiplyScalar(delta));
                
                // Rotation
                s.mesh.rotation.x += s.rotVel.x * delta;
                s.mesh.rotation.y += s.rotVel.y * delta;
                s.mesh.rotation.z += s.rotVel.z * delta;

                // Floor Collision
                if (s.mesh.position.y < 0.01) {
                    s.mesh.position.y = 0.01;
                    s.velocity.y *= -0.5; // Bounce
                    s.velocity.x *= 0.6;
                    s.velocity.z *= 0.6;
                    
                    // Sound on bounce (only if moving fast enough and hasn't bounced too much)
                    if (Math.abs(s.velocity.y) > 0.5 && !s.bounced) {
                        // Removed shell eject sound
                        s.bounced = true; // prevent spam
                    }
                }

                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    shells.splice(i, 1);
                }
            }
            
            // --- Dropped Mag Physics ---
            for (let i = droppedMags.length - 1; i >= 0; i--) {
                const m = droppedMags[i];
                m.life -= delta;
                m.velocity.y -= GRAVITY * delta;
                m.mesh.position.add(m.velocity.clone().multiplyScalar(delta));
                
                // Rotation
                m.mesh.rotation.x += m.rotVel.x * delta;
                m.mesh.rotation.y += m.rotVel.y * delta;
                m.mesh.rotation.z += m.rotVel.z * delta;

                // Floor Collision
                if (m.mesh.position.y < 0.125) { // Roughly half height
                    m.mesh.position.y = 0.125;
                    m.velocity.y *= -0.3; // Low bounce
                    m.velocity.x *= 0.5;
                    m.velocity.z *= 0.5;
                    m.rotVel.multiplyScalar(0.8);
                }

                if (m.life <= 0) {
                    scene.remove(m.mesh);
                    droppedMags.splice(i, 1);
                }
            }

            // --- Grenade Physics ---
            for (let i = grenades.length - 1; i >= 0; i--) {
                const g = grenades[i];
                g.life -= delta;
                
                g.velocity.y -= GRAVITY * delta;
                g.mesh.position.add(g.velocity.clone().multiplyScalar(delta));
                
                if (g.mesh.position.y < 0.1) {
                    g.mesh.position.y = 0.1;
                    g.velocity.y *= -0.5;
                    g.velocity.x *= 0.8;
                    g.velocity.z *= 0.8;
                }

                if (g.life <= 0) {
                    scene.remove(g.mesh);
                    grenades.splice(i, 1);
                    
                    const dist = camera.position.distanceTo(g.mesh.position);
                    const dirToGrenade = g.mesh.position.clone().sub(camera.position).normalize();
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    const dot = camDir.dot(dirToGrenade);
                    
                    if (dist < 40) {
                        let intensity = 1.0;
                        if (dot < 0.5) intensity = 0.1; 
                        intensity *= (1.0 - (dist / 40)); 
                        if(intensity < 0) intensity = 0;
                        flashIntensity = Math.min(flashIntensity + intensity, 1.0);
                        playSound('bang', intensity);
                    }
                }
            }

            if (flashIntensity > 0) {
                flashIntensity -= delta * 0.25; 
                if (flashIntensity < 0) flashIntensity = 0;
                document.getElementById('flash-overlay').style.opacity = flashIntensity;
            }

            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);

            let wishDir = new THREE.Vector3();
            if (moveForward) wishDir.add(forward);
            if (moveBackward) wishDir.sub(forward);
            if (moveRight) wishDir.add(right);
            if (moveLeft) wishDir.sub(right);
            wishDir.normalize();

            let targetHeight = isCrouched ? CROUCH_HEIGHT : STAND_HEIGHT;
            currentEyeHeight = THREE.MathUtils.lerp(currentEyeHeight, targetHeight, delta * 15);

            if (keySpace && isGrounded) {
                velocity.y = JUMP_FORCE;
                isGrounded = false;
            }

            if (isGrounded) {
                applyFriction(delta);
                let speedLimit;
                if (activeWeapon === 'knife') {
                    speedLimit = isCrouched ? CROUCH_SPEED_KNIFE : MAX_SPEED_KNIFE;
                } else if (activeWeapon === 'flash') {
                    speedLimit = isCrouched ? CROUCH_SPEED_KNIFE : MAX_SPEED_KNIFE; 
                } else {
                    speedLimit = isCrouched ? CROUCH_SPEED : MAX_SPEED;
                }
                accelerate(wishDir, speedLimit, ACCEL, delta);
            } else {
                accelerate(wishDir, MAX_AIR_SPEED, AIR_ACCEL, delta);
            }
            
            velocity.y -= GRAVITY * delta;
            camera.position.add(velocity.clone().multiplyScalar(delta));

            if (camera.position.y < currentEyeHeight) {
                // Only land if we are falling or stationary, NOT if we are moving up (jumping)
                if (velocity.y <= 0) {
                    camera.position.y = currentEyeHeight;
                    velocity.y = 0;
                    isGrounded = true;
                    canJump = true;
                } else {
                   // We are jumping up from the ground, don't clamp
                   isGrounded = false;
                }
            } else {
                isGrounded = false;
            }
            if (isGrounded) camera.position.y = currentEyeHeight;

            const decay = 8.0;
            const factor = Math.exp(-decay * delta);
            recoilPitch *= factor;
            recoilYaw *= factor;
            recoilScreenShake *= factor;

            let finalPitch = camPitch + recoilPitch;
            const absLimit = 1.51; 
            if (finalPitch > absLimit) finalPitch = absLimit;
            if (finalPitch < -absLimit) finalPitch = -absLimit;

            const verticalFactor = 1.0 - Math.pow(Math.abs(finalPitch) / 1.57, 4);
            camera.rotation.z = recoilScreenShake * verticalFactor;
            camera.rotation.x = finalPitch;
            camera.rotation.y = camYaw + recoilYaw;

            if (drawTimer < 1.0) {
                drawTimer += delta * 3.0; 
                if (drawTimer > 1.0) drawTimer = 1.0;
            }
            const drawOffset = (1.0 - Math.pow(drawTimer, 0.5)) * -0.5;

            swayPos.x = THREE.MathUtils.lerp(swayPos.x, 0, delta * 10);
            swayPos.y = THREE.MathUtils.lerp(swayPos.y, 0, delta * 10);

            const speedMagnitude = new THREE.Vector2(velocity.x, velocity.z).length();
            let bobX = 0, bobY = 0;
            if (isGrounded && speedMagnitude > 0.1) {
                bobTimer += delta * 15; 
                bobX = Math.cos(bobTimer) * 0.005;
                bobY = Math.sin(bobTimer * 2) * 0.005;
            } else {
                bobTimer = 0;
            }

            if (activeWeapon === 'rifle') {
                if (!isReloading) {
                    rifleGroup.position.set(
                        weaponBasePos.x + swayPos.x + bobX,
                        weaponBasePos.y + swayPos.y + bobY + drawOffset,
                        weaponBasePos.z
                    );
                    
                    if (isInspecting) {
                        inspectTimer += delta;
                        
                        // --- INVESTIGATIVE INSPECT ANIMATION ---
                        // Total Duration: ~3.5s
                        // 1. Lift & Check Side (0s - 1.5s)
                        // 2. Roll & Check Top (1.5s - 3.5s)
                        // 3. Auto-return (handled by else block)

                        if (inspectTimer < 1.5) {
                            // Phase 1: Smooth lift to check the side/magwell
                            const t = Math.min(inspectTimer / 1.2, 1);
                            const ease = 1 - Math.pow(1 - t, 3); // Cubic Ease Out
                            
                            // Rotate Y to show side, Z to tilt mag up slightly
                            rifleGroup.rotation.y = ease * 1.0; 
                            rifleGroup.rotation.z = ease * 0.35;
                            rifleGroup.rotation.x = ease * 0.15;
                            
                            // Bring closer and center
                            rifleGroup.position.x = weaponBasePos.x - (ease * 0.12);
                            rifleGroup.position.y = weaponBasePos.y + (ease * 0.08);
                            rifleGroup.position.z = weaponBasePos.z + (ease * 0.05);
                        } 
                        else if (inspectTimer < 3.5) {
                            // Phase 2: Slow smooth transition to looking at the top
                            const t = (inspectTimer - 1.5) / 2.0; 
                            const smooth = t * t * (3 - 2 * t); // Smoothstep curve
                            
                            // Rotate from Side View to Top/Angle View
                            rifleGroup.rotation.y = THREE.MathUtils.lerp(1.0, 0.4, smooth);
                            rifleGroup.rotation.z = THREE.MathUtils.lerp(0.35, -0.1, smooth);
                            rifleGroup.rotation.x = THREE.MathUtils.lerp(0.15, 0.05, smooth);
                            
                            // Slight breathing bob to simulate focus
                            const bob = Math.sin(t * Math.PI * 2) * 0.005;
                            rifleGroup.position.y = weaponBasePos.y + 0.08 + bob;
                            // Drift back right slightly
                            rifleGroup.position.x = THREE.MathUtils.lerp(weaponBasePos.x - 0.12, weaponBasePos.x - 0.05, smooth);
                        }
                        else {
                            isInspecting = false;
                        }
                    } else {
                        // Smooth return to idle
                        rifleGroup.rotation.x = THREE.MathUtils.lerp(rifleGroup.rotation.x, 0, delta * 8);
                        rifleGroup.rotation.y = THREE.MathUtils.lerp(rifleGroup.rotation.y, 0, delta * 8);
                        rifleGroup.rotation.z = THREE.MathUtils.lerp(rifleGroup.rotation.z, 0, delta * 8);
                        
                        // Positional return is handled by the main position.set logic at top of block
                    }
                }
                
                if (muzzleLight.intensity > 0) muzzleLight.intensity -= delta * 30;
                if (isFiring && time - lastFireTime > FIRE_RATE) {
                    fireRifle();
                    lastFireTime = time;
                }
                currentSpread = THREE.MathUtils.lerp(currentSpread, 0, delta * 5);
            
            } else if (activeWeapon === 'knife') {
                
                let targetPos = knifeBasePos.clone();
                let targetRot = new THREE.Euler(0, 0, 0);

                if (isAttackingKnife) {
                    knifeAttackTimer += delta;
                    const slashDuration = 0.35;
                    const progress = knifeAttackTimer / slashDuration;
                    
                    if (progress < 0.2) {
                         targetPos.x += 0.15;
                         targetPos.y += 0.15;
                         targetRot.z = -0.5; 
                         targetRot.y = -0.3;
                    } else if (progress < 0.6) {
                        targetPos.x -= 0.4; 
                        targetPos.y -= 0.1;
                        targetPos.z -= 0.3; 
                        
                        targetRot.z = 1.2; 
                        targetRot.x = -0.4;
                        targetRot.y = 0.8;
                    }
                    if (knifeAttackTimer > slashDuration) isAttackingKnife = false;
                } 
                else if (isInspecting) {
                    inspectTimer += delta;
                    if (isInspectHeld) inspectHoldTimer += delta; 
                    else inspectHoldTimer = 0;

                    if (isInspectHeld && inspectHoldTimer > 0.5) {
                         isSpinning = true;
                    }

                    if (isSpinning) {
                        const spinTime = inspectTimer - 0.5; 
                        const spinSpeed = 15.0;
                        
                        targetRot.z = -spinTime * spinSpeed; 
                        targetRot.x = Math.sin(spinTime * 12) * 0.3;
                        targetPos.y += Math.sin(spinTime * 12) * 0.02;

                        if (!isInspectHeld) {
                             isInspecting = false;
                             isSpinning = false;
                        }
                    } 
                    else {
                        if (inspectTimer < 0.4) {
                            const t = inspectTimer / 0.4;
                            const ease = 1 - Math.pow(1 - t, 3);
                            targetRot.z = -Math.PI * 2 * ease; 
                            targetRot.x = Math.sin(t * Math.PI) * 0.5; 
                            targetPos.y += Math.sin(t * Math.PI) * 0.05;
                        } 
                        else {
                            const baseRotZ = -Math.PI * 2;
                            const t = inspectTimer - 0.4;
                            
                            const blend = Math.min(t * 3.0, 1.0); 
                            const lookZ = 0.8;
                            const lookY = 0.5;
                            
                            targetRot.z = baseRotZ + THREE.MathUtils.lerp(0, lookZ, blend);
                            targetRot.y = THREE.MathUtils.lerp(0, lookY, blend);
                            
                            if (blend >= 1.0) {
                                const swayT = t - 0.3;
                                targetRot.z += Math.sin(swayT) * 0.05;
                                targetRot.y += Math.cos(swayT * 0.7) * 0.1;
                                targetRot.x = 0.2 + Math.sin(swayT * 1.5) * 0.05;
                            }
                            
                            targetPos.x = THREE.MathUtils.lerp(targetPos.x, 0.0, blend);
                            targetPos.y = THREE.MathUtils.lerp(targetPos.y, -0.25, blend);
                            
                            if (inspectTimer > 4.0 && !isInspectHeld) isInspecting = false;
                        }
                    }
                }

                const smooth = delta * 15;
                knifeGroup.position.set(
                    THREE.MathUtils.lerp(knifeGroup.position.x, targetPos.x + swayPos.x + bobX, smooth),
                    THREE.MathUtils.lerp(knifeGroup.position.y, targetPos.y + swayPos.y + bobY + drawOffset, smooth),
                    THREE.MathUtils.lerp(knifeGroup.position.z, targetPos.z, smooth)
                );
                
                knifeGroup.rotation.x = THREE.MathUtils.lerp(knifeGroup.rotation.x, targetRot.x, smooth);
                knifeGroup.rotation.y = THREE.MathUtils.lerp(knifeGroup.rotation.y, targetRot.y, smooth);
                knifeGroup.rotation.z = THREE.MathUtils.lerp(knifeGroup.rotation.z, targetRot.z, smooth);

            } else if (activeWeapon === 'flash') {
                let targetPos = flashBasePos.clone();
                let targetRot = new THREE.Euler(0, 0, 0);
                
                const grenadePart = flashGroup.children[0];
                const handPart = flashGroup.children[1];

                if (isThrowingFlash) {
                    grenadePart.position.set(0, 0.03, 0);
                    grenadePart.rotation.set(Math.PI / 2, 0, 0);
                    handPart.position.set(0, -0.05, 0);
                    handPart.rotation.set(0, 0, 0);

                    flashThrowTimer += delta;
                    if (flashThrowTimer < 0.2) {
                        targetPos.x += 0.2;
                        targetPos.y += 0.2;
                        targetRot.z = -0.5;
                    } else if (flashThrowTimer < 0.4) {
                        targetPos.x -= 0.2;
                        targetPos.y -= 0.2;
                        targetPos.z -= 0.5;
                        targetRot.x = 1.0; 
                    } else {
                        targetPos.y = -2.0; 
                        if (flashThrowTimer > 1.0) isThrowingFlash = false;
                    }
                } 
                else if (isInspecting) {
                    inspectTimer += delta;
                    const juggleSpeed = 0.6; 
                    const t = (inspectTimer % juggleSpeed) / juggleSpeed; 
                    const height = 0.2 * (4 * t * (1 - t)); 
                    grenadePart.position.y = 0.03 + height;
                    grenadePart.rotation.x = (Math.PI / 2) - (inspectTimer * Math.PI * 4); 
                    const handOffset = Math.cos(t * Math.PI * 2) * 0.02;
                    const handFlick = Math.sin(t * Math.PI * 2) * 0.1;
                    handPart.position.y = -0.05 + handOffset; 
                    handPart.rotation.x = -handFlick; 
                } else {
                    grenadePart.position.set(0, 0.03, 0);
                    grenadePart.rotation.set(Math.PI / 2, 0, 0);
                    handPart.position.set(0, -0.05, 0);
                    handPart.rotation.set(0, 0, 0);
                }

                const smooth = delta * 15;
                flashGroup.position.set(
                    THREE.MathUtils.lerp(flashGroup.position.x, targetPos.x + swayPos.x + bobX, smooth),
                    THREE.MathUtils.lerp(flashGroup.position.y, targetPos.y + swayPos.y + bobY + drawOffset, smooth),
                    THREE.MathUtils.lerp(flashGroup.position.z, targetPos.z, smooth)
                );
                flashGroup.rotation.x = THREE.MathUtils.lerp(flashGroup.rotation.x, targetRot.x, smooth);
                flashGroup.rotation.y = THREE.MathUtils.lerp(flashGroup.rotation.y, targetRot.y, smooth);
                flashGroup.rotation.z = THREE.MathUtils.lerp(flashGroup.rotation.z, targetRot.z, smooth);
            }

            updateCrosshair(velocity);
        }
    </script>
</body>
</html>
