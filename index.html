<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS:GO Gun Sim</title>
    <!-- Import Map to resolve 'three' inside GLTFLoader -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* HUD Elements */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0px;
            height: 0px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        .ch-line {
            position: absolute;
            background-color: #00ff00;
            box-shadow: 0 0 2px #000;
            transition: all 0.05s ease-out;
        }
        
        .ch-top { width: 2px; height: 10px; top: -14px; left: -1px; }
        .ch-bottom { width: 2px; height: 10px; top: 4px; left: -1px; }
        .ch-left { width: 10px; height: 2px; top: -1px; left: -14px; }
        .ch-right { width: 10px; height: 2px; top: -1px; left: 4px; }

        #hud {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #ammo-box { display: flex; flex-direction: column; align-items: flex-end; }
        #ammo-count { font-size: 42px; color: #ddd; }
        #ammo-reserve { font-size: 20px; color: #aaa; }

        #weapon-icon {
            width: 120px;
            height: 40px;
            background: rgba(0,0,0,0.3);
            border: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: #ccc;
            border-radius: 4px;
            text-transform: uppercase;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.85);
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #555;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 10;
        }

        /* Debug UI for testing locally */
        #debug-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 999;
        }
        .debug-btn {
            background: #333;
            color: #aaa;
            border: 1px solid #555;
            padding: 5px 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            border-radius: 4px;
        }
        .debug-btn:hover { background: #444; color: #fff; }

        /* Loading Status UI */
        #status-log {
            position: absolute;
            top: 40px;
            left: 10px;
            color: #ffff00;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 4px;
            z-index: 100;
            max-width: 300px;
        }

        .key {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #666;
            font-size: 0.9em;
            color: #fff;
            margin: 0 2px;
        }
    </style>
</head>
<body>

    <div id="status-log">Initializing...</div>

    <!-- Debug UI: Helps you test the model in preview without hosting it -->
    <div id="debug-ui">
        <button class="debug-btn" onclick="document.getElementById('file-input').click()">Load ak-47.glb (Manual)</button>
        <input type="file" id="file-input" style="display:none;" accept=".glb,.gltf">
    </div>

    <!-- HUD -->
    <div id="crosshair">
        <div class="ch-line ch-top" id="ch-top"></div>
        <div class="ch-line ch-bottom" id="ch-bottom"></div>
        <div class="ch-line ch-left" id="ch-left"></div>
        <div class="ch-line ch-right" id="ch-right"></div>
    </div>

    <div id="hud">
        <div id="weapon-icon">AK-47</div>
        <div id="ammo-box">
            <span id="ammo-count">30</span>
            <span id="ammo-reserve">/ 90</span>
        </div>
    </div>

    <div id="instructions">
        <h1 style="margin-top:0;">CS:GO Gun Sim</h1>
        <p>Click to Start</p>
        <p><span class="key">WASD</span> Move &nbsp; <span class="key">SPACE</span> Jump</p>
        <p><span class="key">CTRL</span> / <span class="key">C</span> Crouch &nbsp; <span class="key">R</span> Reload</p>
        <p><span class="key">1</span> Rifle &nbsp; <span class="key">3</span> Knife</p>
        <p><span class="key">F</span> Inspect &nbsp; <span class="key">L-Click</span> Shoot</p>
    </div>

    <!-- Three.js from CDN -->
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

        // --- STATUS LOGGER ---
        const logEl = document.getElementById('status-log');
        function log(msg, color = '#ffff00') {
            logEl.innerText = msg;
            logEl.style.color = color;
            console.log(msg);
        }

        // --- CONSTANTS ---
        const MAX_SPEED = 6.0;
        const MAX_SPEED_KNIFE = 9.0; 
        const CROUCH_SPEED = 2.25;   
        const CROUCH_SPEED_KNIFE = 3.375; 
        
        const MAX_AIR_SPEED = 0.8;     
        const ACCEL = 6.5;             
        const AIR_ACCEL = 50.0;        
        const FRICTION = 6.0;          
        const STOP_SPEED = 2.0;        
        const GRAVITY = 18.0;          
        const JUMP_FORCE = 6.5;        

        const STAND_HEIGHT = 1.7;
        const CROUCH_HEIGHT = 1.2;

        const SENSITIVITY = 0.002;
        const FIRE_RATE = 100; 
        const MAG_SIZE = 30;
        const RELOAD_TIME = 2000; 
        
        // --- State ---
        let camera, scene, renderer;
        let playerHand, rifleGroup, knifeGroup, customModelMesh, muzzleFlashMesh, muzzleLight;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let keySpace = false, isCrouched = false, canJump = false, isGrounded = false, isLocked = false;
        let velocity = new THREE.Vector3(); 
        let prevTime = performance.now();
        let currentEyeHeight = STAND_HEIGHT;
        let camPitch = 0, camYaw = 0;
        let recoilPitch = 0, recoilYaw = 0, recoilScreenShake = 0;
        let activeWeapon = 'rifle'; 
        let isFiring = false, lastFireTime = 0;
        let currentAmmo = 30, reserveAmmo = 90, isReloading = false, currentSpread = 0;
        let weaponBasePos = new THREE.Vector3(0.35, -0.4, -0.7); 
        let knifeBasePos = new THREE.Vector3(0.25, -0.2, -0.45); 
        let swayPos = new THREE.Vector3(0,0,0);
        let bobTimer = 0;
        let isInspecting = false, inspectTimer = 0, drawTimer = 0; 
        let isAttackingKnife = false, knifeAttackTimer = 0;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        init();
        animate();

        function init() {
            // Check for file:// protocol
            if (window.location.protocol === 'file:') {
                log("ERROR: Running from local file.\nBrowsers block 3D models here.\nUse a Local Server or GitHub Pages.", "#ff4444");
            } else {
                log("Ready. Use 'Manual Load' for local files.", "#00ff00");
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 70);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            createLevel();
            createPlayerModel();

            // Set up manual file listener (for testing/preview)
            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if(file) {
                    const url = URL.createObjectURL(file);
                    loadCustomGLB(url, false);
                }
            });

            // AUTOMATIC LOADING OF MODEL (For GitHub Repo)
            // Expects 'ak-47.glb' to be in the same folder as this index.html
            // CRITICAL FIX: Only attempt auto-load if NOT in a Blob/Preview environment to prevent Invalid URL crash
            const proto = window.location.protocol;
            if (proto !== 'blob:' && proto !== 'data:') {
                loadCustomGLB('ak-47.glb', true);
            } else {
                log("Preview Mode detected.\nAuto-load skipped to prevent errors.\nUse the button to load model.", "#aaaaff");
            }

            // Inputs
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', (e) => { 
                if(isLocked && e.button === 0) startFire();
            });
            document.addEventListener('mouseup', () => { isFiring = false; });
            document.addEventListener('mousemove', onMouseMove);
            
            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', () => {
                document.body.requestPointerLock();
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === document.body) {
                    isLocked = true;
                    instructions.style.display = 'none';
                    audioCtx.resume();
                } else {
                    isLocked = false;
                    instructions.style.display = 'block';
                    isFiring = false;
                }
            });

            window.addEventListener('resize', onWindowResize);
        }

        function loadCustomGLB(url, isAuto = false) {
            if(!isAuto) log("Loading custom model...", "#ffff00");
            const loader = new GLTFLoader();
            
            try {
                loader.load(url, (gltf) => {
                    log("Model Loaded Successfully!", "#00ff00");
                    
                    if (customModelMesh) {
                        // Remove fallback placeholder
                        while(customModelMesh.children.length > 0){ 
                            customModelMesh.remove(customModelMesh.children[0]); 
                        }
                        
                        const model = gltf.scene;
                        
                        // Auto-Scale
                        const box = new THREE.Box3().setFromObject(model);
                        const size = new THREE.Vector3();
                        box.getSize(size);
                        const maxDim = Math.max(size.x, size.y, size.z);
                        
                        // Target ~0.85 units long
                        if (maxDim > 0) {
                            const scaleFactor = 0.85 / maxDim;
                            model.scale.setScalar(scaleFactor);
                        }

                        // Re-center
                        const box2 = new THREE.Box3().setFromObject(model);
                        const center = new THREE.Vector3();
                        box2.getCenter(center);
                        model.position.sub(center); 
                        
                        // Rotation (Most guns need -90deg Y)
                        model.rotation.y = -Math.PI / 2;

                        model.traverse((n) => { 
                            if(n.isMesh) {
                                n.castShadow = true;
                                n.receiveShadow = true;
                            }
                        });

                        customModelMesh.add(model);
                    }
                }, 
                undefined, 
                (err) => {
                    console.error(err);
                    if (window.location.protocol === 'file:') {
                        log("BLOCKED: Browser cannot load local files.\nSolution: Upload to GitHub Pages.", "#ff4444");
                    } else if (isAuto) {
                        // Silent fail for auto-load in case file is missing
                        console.warn("Auto-load failed (file missing or network error).");
                    } else {
                        log("Error loading model. See console.", "#ff4444");
                    }
                });
            } catch(e) {
                console.warn("Loader synchronous error:", e);
            }
        }

        function createLevel() {
            const floorGeo = new THREE.PlaneGeometry(100, 100);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xddccaa, roughness: 0.8 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            const wallMat = new THREE.MeshStandardMaterial({ color: 0xccbb99 });
            const createWall = (x, y, z, w, h, d) => {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mesh = new THREE.Mesh(geo, wallMat);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }

            createWall(0, 5, -20, 40, 10, 1);
            createWall(-20, 5, 0, 1, 10, 40);
            createWall(20, 5, 0, 1, 10, 40);
            createWall(0, 5, 20, 40, 10, 1);

            const crateMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const createCrate = (x, z, s) => {
                const geo = new THREE.BoxGeometry(s, s, s);
                const mesh = new THREE.Mesh(geo, crateMat);
                mesh.position.set(x, s/2, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }
            createCrate(0, -10, 2);
            createCrate(5, -15, 3);
            createCrate(-5, -8, 2);
            createCrate(8, 5, 2);
        }

        function createPlayerModel() {
            playerHand = new THREE.Group();
            camera.add(playerHand);
            scene.add(camera);

            rifleGroup = createAK47();
            knifeGroup = createM9Bayonet();

            playerHand.add(rifleGroup);
            playerHand.add(knifeGroup);

            switchWeapon('rifle');
        }

        function createAK47() {
            const group = new THREE.Group();
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6 }); 

            // -- CUSTOM MODEL CONTAINER --
            customModelMesh = new THREE.Group();
            // Placeholder: Grey box
            const fallbackGeo = new THREE.BoxGeometry(0.08, 0.2, 0.6);
            const fallbackMat = new THREE.MeshStandardMaterial({color: 0x555555});
            const fallback = new THREE.Mesh(fallbackGeo, fallbackMat);
            customModelMesh.add(fallback); 
            group.add(customModelMesh);

            // Hands
            const rHand = new THREE.Group();
            rHand.position.set(0, -0.12, 0.25);
            rHand.rotation.x = -0.2;
            const rPalm = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.09, 0.05), skinMat);
            rHand.add(rPalm);
            const rIndex = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.07, 8), skinMat);
            rIndex.position.set(0.02, 0.03, -0.03);
            rIndex.rotation.set(0.5, 0, 0);
            rHand.add(rIndex);
            const rArm = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.04, 0.7, 16), skinMat);
            rArm.position.set(0.25, -0.4, 0.65);
            rArm.lookAt(rHand.position);
            rArm.rotateX(-Math.PI / 2);
            rArm.position.add(new THREE.Vector3(0, -0.05, 0));
            group.add(rHand);
            group.add(rArm);

            const lHand = new THREE.Group();
            lHand.position.set(0, -0.06, -0.35);
            const lPalm = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.025, 0.07), skinMat);
            lPalm.position.y = -0.02;
            lHand.add(lPalm);
            const lThumb = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.07, 8), skinMat);
            lThumb.position.set(0.04, 0.01, -0.01);
            lThumb.rotation.set(0.2, -0.3, 1.2);
            lHand.add(lThumb);
            for(let i=0; i<4; i++) {
                const f = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.08, 8), skinMat);
                f.position.set(-0.04, 0.01, 0.025 - (i * 0.018));
                f.rotation.set(0, 0, -1.0);
                lHand.add(f);
            }
            const lArm = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.04, 1.2, 16), skinMat);
            lArm.position.set(-0.3, -0.45, 0.1);
            lArm.lookAt(lHand.position);
            lArm.rotateX(-Math.PI / 2);
            group.add(lHand);
            group.add(lArm);

            const flashGeo = new THREE.PlaneGeometry(0.3, 0.3);
            const flashMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
            muzzleFlashMesh = new THREE.Mesh(flashGeo, flashMat);
            muzzleFlashMesh.position.set(0, 0.02, -0.9); 
            muzzleFlashMesh.visible = false;
            group.add(muzzleFlashMesh);

            muzzleLight = new THREE.PointLight(0xffaa00, 0, 10);
            muzzleLight.position.set(0, 0.05, -1.0);
            group.add(muzzleLight);

            return group;
        }

        function createM9Bayonet() {
            const group = new THREE.Group();
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.8, roughness: 0.1 }); 
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
            const guardMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.6 });

            const weaponWrapper = new THREE.Group();
            weaponWrapper.rotation.set(0, 0, -0.2); 
            
            const handleGeo = new THREE.CylinderGeometry(0.022, 0.025, 0.13, 12);
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = 0.01;
            handle.scale.set(1, 1, 0.8);
            weaponWrapper.add(handle);

            const pommel = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.022, 0.02, 12), guardMat);
            pommel.position.y = -0.065;
            weaponWrapper.add(pommel);

            const guard = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.06, 0.02), guardMat);
            guard.position.y = 0.08;
            weaponWrapper.add(guard);
            
            const bladeGeo = new THREE.BoxGeometry(0.006, 0.25, 0.035);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.215; 
            
            const positions = blade.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                if (y > 0) positions[i] *= (1 - (y / 0.15) * 0.5);
                if (positions[i+2] < 0) positions[i+2] *= 0.1;
            }
            blade.geometry.attributes.position.needsUpdate = true;
            weaponWrapper.add(blade);
            group.add(weaponWrapper);

            const handGroup = new THREE.Group();
            const palm = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.05), skinMat);
            palm.position.set(0.03, 0, 0); 
            handGroup.add(palm);

            const f1 = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.09, 8), skinMat);
            f1.rotation.z = Math.PI / 2;
            f1.position.set(0.03, 0.04, 0.035);
            f1.rotation.x = 0.2;
            handGroup.add(f1);
            
            const f2 = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.095, 8), skinMat);
            f2.rotation.z = Math.PI / 2;
            f2.position.set(0.03, 0.015, 0.035);
            f2.rotation.x = 0.1;
            handGroup.add(f2);

            const f3 = new THREE.Mesh(new THREE.CylinderGeometry(0.011, 0.011, 0.09, 8), skinMat);
            f3.rotation.z = Math.PI / 2;
            f3.position.set(0.03, -0.01, 0.035);
            handGroup.add(f3);

            const f4 = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.075, 8), skinMat);
            f4.rotation.z = Math.PI / 2;
            f4.position.set(0.03, -0.035, 0.035);
            f4.rotation.x = -0.1;
            handGroup.add(f4);

            const thumb = new THREE.Mesh(new THREE.CylinderGeometry(0.013, 0.013, 0.07, 8), skinMat);
            thumb.position.set(0.04, 0.03, -0.03);
            thumb.rotation.set(0.5, 0.5, 0);
            handGroup.add(thumb);

            group.add(handGroup);
            group.rotation.set(0, 0, 0); 
            return group;
        }

        function switchWeapon(type) {
            if (activeWeapon === type || isReloading || isAttackingKnife) return;
            
            isInspecting = false;
            inspectTimer = 0;
            isFiring = false;
            
            activeWeapon = type;
            drawTimer = 0; 

            if (type === 'rifle') {
                rifleGroup.visible = true;
                knifeGroup.visible = false;
                document.getElementById('weapon-icon').innerText = "AK-47";
                document.getElementById('ammo-box').style.opacity = "1";
                document.querySelectorAll('.ch-line').forEach(el => el.style.backgroundColor = '#00ff00');
            } else {
                rifleGroup.visible = false;
                knifeGroup.visible = true;
                document.getElementById('weapon-icon').innerText = "M9 BAYONET";
                document.getElementById('ammo-box').style.opacity = "0.3"; 
                document.querySelectorAll('.ch-line').forEach(el => el.style.backgroundColor = 'rgba(255, 255, 255, 0.3)');
            }
        }

        function startFire() {
            if (isInspecting) isInspecting = false;
            if (activeWeapon === 'rifle') isFiring = true;
            else if (activeWeapon === 'knife') stab();
        }

        function stab() {
            if (isAttackingKnife || drawTimer < 0.8) return;
            isAttackingKnife = true;
            knifeAttackTimer = 0;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = 2.5; 
            const intersects = raycaster.intersectObjects(scene.children);
            playSound('swish');

            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.object.geometry.type !== 'PlaneGeometry' || hit.distance < 2.0) {
                     setTimeout(() => {
                        createBulletHole(hit.point, hit.face.normal, true);
                        playSound('stab_hit');
                     }, 150);
                }
            }
        }

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const t = audioCtx.currentTime;
            
            if (type === 'shoot') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(20, t + 0.1);
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc.start(t);
                osc.stop(t + 0.2);
                
                const noiseSize = audioCtx.sampleRate * 0.2;
                const buffer = audioCtx.createBuffer(1, noiseSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < noiseSize; i++) data[i] = Math.random() * 2 - 1;
                const noiseSrc = audioCtx.createBufferSource();
                noiseSrc.buffer = buffer;
                const noiseGain = audioCtx.createGain();
                noiseSrc.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noiseGain.gain.setValueAtTime(0.5, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                noiseSrc.start(t);

            } else if (type === 'swish') {
                const bufferSize = audioCtx.sampleRate * 0.3;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.Q.value = 0.5;
                filter.frequency.setValueAtTime(600, t);
                filter.frequency.linearRampToValueAtTime(3000, t + 0.1);
                filter.frequency.linearRampToValueAtTime(600, t + 0.25); 
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.01, t);
                gain.gain.linearRampToValueAtTime(0.6, t + 0.08); 
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.25); 
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(t);
                noise.stop(t + 0.3);

            } else if (type === 'stab_hit') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(40, t + 0.05);
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                osc.start(t);
                osc.stop(t + 0.1);
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyR': if(activeWeapon === 'rifle') reload(); break;
                case 'ControlLeft': case 'ControlRight': case 'KeyC': isCrouched = true; break;
                case 'Digit1': switchWeapon('rifle'); break;
                case 'Digit3': switchWeapon('knife'); break;
                case 'KeyF': 
                    if(!isReloading && !isFiring && !isAttackingKnife) {
                        isInspecting = true; 
                        inspectTimer = 0; 
                    }
                    break;
                case 'Space': keySpace = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ControlLeft': case 'ControlRight': case 'KeyC': isCrouched = false; break;
                case 'Space': keySpace = false; break;
            }
        }

        function onMouseMove(event) {
            if (!isLocked) return;
            if (Math.abs(event.movementX) > 100 || Math.abs(event.movementY) > 100) return;
            camYaw -= event.movementX * SENSITIVITY;
            camPitch -= event.movementY * SENSITIVITY;
            const limit = 1.51; 
            if (camPitch > limit) camPitch = limit;
            if (camPitch < -limit) camPitch = -limit;
            const maxSway = 0.06;
            const swayX = Math.max(-maxSway, Math.min(maxSway, -event.movementX * 0.0006));
            const swayY = Math.max(-maxSway, Math.min(maxSway, -event.movementY * 0.0006));
            swayPos.x = swayX;
            swayPos.y = swayY;
        }

        function fireRifle() {
            if (isReloading || isInspecting) return; 
            if (currentAmmo <= 0) { reload(); isFiring = false; return; }

            currentAmmo--;
            updateHUD();
            playSound('shoot');

            let kickUp = 0.11 + Math.random() * 0.06; 
            let kickSide = (Math.random() - 0.5) * 0.1;
            const recoilMod = isCrouched ? 0.3 : 1.0;
            kickUp *= recoilMod;
            kickSide *= recoilMod;

            recoilPitch += kickUp;
            recoilYaw += kickSide;
            recoilScreenShake = (Math.random() - 0.5) * 0.08 * recoilMod;

            rifleGroup.position.z += 0.25; 
            rifleGroup.rotation.x += 0.2;   

            muzzleFlashMesh.visible = true;
            muzzleFlashMesh.rotation.z = Math.random() * Math.PI * 2;
            const scale = 0.8 + Math.random() * 0.5;
            muzzleFlashMesh.scale.set(scale, scale, 1);
            muzzleLight.intensity = 4.0;
            setTimeout(() => { muzzleFlashMesh.visible = false; }, 40);

            const horizSpeed = new THREE.Vector2(velocity.x, velocity.z).length();
            let spreadFactor = 0.008; 
            if (horizSpeed > 0.1) spreadFactor += (horizSpeed / MAX_SPEED) * 0.15;
            if (!isGrounded) spreadFactor += 0.1;
            if (isCrouched) {
                if (horizSpeed < 0.1) spreadFactor = 0.0005; 
                else spreadFactor *= 0.4;
            }
            currentSpread = spreadFactor * 50.0; 

            const spreadX = (Math.random() - 0.5) * spreadFactor;
            const spreadY = (Math.random() - 0.5) * spreadFactor;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(spreadX, spreadY), camera);
            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.object !== muzzleFlashMesh && !playerHand.children.includes(hit.object)) {
                    createBulletHole(hit.point, hit.face.normal);
                }
            }
        }

        function createBulletHole(position, normal, isKnife = false) {
            const size = isKnife ? 0.15 : 0.1;
            const decal = new THREE.Mesh(
                new THREE.PlaneGeometry(size, size),
                new THREE.MeshBasicMaterial({ color: isKnife ? 0x333333 : 0x111111, side: THREE.DoubleSide })
            );
            decal.position.copy(position).add(normal.clone().multiplyScalar(0.01));
            decal.lookAt(position.clone().add(normal));
            if(isKnife) decal.rotation.z = Math.random() * Math.PI; 
            scene.add(decal);
            setTimeout(() => { scene.remove(decal); }, 10000);
        }

        function reload() {
            if (isReloading || currentAmmo === MAG_SIZE || reserveAmmo <= 0) return;
            isReloading = true;
            isInspecting = false;
            
            const initialRot = rifleGroup.rotation.x;
            const downRot = initialRot - 1.0;
            let startTime = performance.now();
            
            const animateReload = () => {
                const now = performance.now();
                const progress = (now - startTime) / RELOAD_TIME;
                if (progress < 0.2) rifleGroup.rotation.x = THREE.MathUtils.lerp(initialRot, downRot, progress * 5);
                else if (progress > 0.8) rifleGroup.rotation.x = THREE.MathUtils.lerp(downRot, initialRot, (progress - 0.8) * 5);
                if (progress < 1) requestAnimationFrame(animateReload);
                else {
                    rifleGroup.rotation.x = initialRot;
                    const needed = MAG_SIZE - currentAmmo;
                    const toAdd = Math.min(needed, reserveAmmo);
                    currentAmmo += toAdd;
                    reserveAmmo -= toAdd;
                    isReloading = false;
                    updateHUD();
                }
            };
            animateReload();
        }

        function updateHUD() {
            document.getElementById('ammo-count').innerText = currentAmmo;
            document.getElementById('ammo-reserve').innerText = "/ " + reserveAmmo;
        }

        function updateCrosshair(vel) {
            if (activeWeapon === 'knife') {
                const top = document.getElementById('ch-top');
                const bot = document.getElementById('ch-bottom');
                const left = document.getElementById('ch-left');
                const right = document.getElementById('ch-right');
                top.style.top = `-8px`; bot.style.top = `2px`;
                left.style.left = `-8px`; right.style.left = `2px`;
                return;
            }
            const speed = new THREE.Vector2(vel.x, vel.z).length();
            let gap = 5;
            if (speed > 0.1) gap += (speed / MAX_SPEED) * 50; 
            if (!isGrounded) gap += 30; 
            gap += currentSpread; 
            gap = Math.min(gap, 100);
            const top = document.getElementById('ch-top');
            const bot = document.getElementById('ch-bottom');
            const left = document.getElementById('ch-left');
            const right = document.getElementById('ch-right');
            top.style.top = `-${14 + gap}px`;
            bot.style.top = `${4 + gap}px`;
            left.style.left = `-${14 + gap}px`;
            right.style.left = `${4 + gap}px`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function applyFriction(delta) {
            const speed = new THREE.Vector2(velocity.x, velocity.z).length();
            if (speed < 0.1) return;
            const control = (speed < STOP_SPEED) ? STOP_SPEED : speed;
            const drop = control * FRICTION * delta;
            let newSpeed = speed - drop;
            if (newSpeed < 0) newSpeed = 0;
            if (newSpeed !== speed) {
                newSpeed /= speed;
                velocity.x *= newSpeed;
                velocity.z *= newSpeed;
            }
        }

        function accelerate(wishDir, wishSpeed, accel, delta) {
            const currentSpeed = (velocity.x * wishDir.x) + (velocity.z * wishDir.z);
            const addSpeed = wishSpeed - currentSpeed;
            if (addSpeed <= 0) return;
            let accelSpeed = accel * delta * wishSpeed;
            if (accelSpeed > addSpeed) accelSpeed = addSpeed;
            velocity.x += accelSpeed * wishDir.x;
            velocity.z += accelSpeed * wishDir.z;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);
            prevTime = time;

            if (!isLocked) {
                renderer.render(scene, camera);
                return;
            }

            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);
            let wishDir = new THREE.Vector3();
            if (moveForward) wishDir.add(forward);
            if (moveBackward) wishDir.sub(forward);
            if (moveRight) wishDir.add(right);
            if (moveLeft) wishDir.sub(right);
            wishDir.normalize();

            let targetHeight = isCrouched ? CROUCH_HEIGHT : STAND_HEIGHT;
            currentEyeHeight = THREE.MathUtils.lerp(currentEyeHeight, targetHeight, delta * 15);

            if (keySpace && isGrounded) {
                velocity.y = JUMP_FORCE;
                isGrounded = false;
            }

            if (isGrounded) {
                applyFriction(delta);
                let speedLimit;
                if (activeWeapon === 'knife') {
                    speedLimit = isCrouched ? CROUCH_SPEED_KNIFE : MAX_SPEED_KNIFE;
                } else {
                    speedLimit = isCrouched ? CROUCH_SPEED : MAX_SPEED;
                }
                accelerate(wishDir, speedLimit, ACCEL, delta);
            } else {
                accelerate(wishDir, MAX_AIR_SPEED, AIR_ACCEL, delta);
            }
            
            velocity.y -= GRAVITY * delta;
            camera.position.add(velocity.clone().multiplyScalar(delta));

            if (camera.position.y < currentEyeHeight) {
                camera.position.y = currentEyeHeight;
                if (velocity.y < 0) {
                    velocity.y = 0;
                    isGrounded = true;
                    canJump = true;
                }
            } else {
                isGrounded = false;
            }
            if (isGrounded) camera.position.y = currentEyeHeight;

            const decay = 8.0;
            const factor = Math.exp(-decay * delta);
            recoilPitch *= factor;
            recoilYaw *= factor;
            recoilScreenShake *= factor;

            let finalPitch = camPitch + recoilPitch;
            const absLimit = 1.51; 
            if (finalPitch > absLimit) finalPitch = absLimit;
            if (finalPitch < -absLimit) finalPitch = -absLimit;

            const verticalFactor = 1.0 - Math.pow(Math.abs(finalPitch) / 1.57, 4);
            camera.rotation.z = recoilScreenShake * verticalFactor;
            camera.rotation.x = finalPitch;
            camera.rotation.y = camYaw + recoilYaw;

            if (drawTimer < 1.0) {
                drawTimer += delta * 3.0; 
                if (drawTimer > 1.0) drawTimer = 1.0;
            }
            const drawOffset = (1.0 - Math.pow(drawTimer, 0.5)) * -0.5;

            swayPos.x = THREE.MathUtils.lerp(swayPos.x, 0, delta * 10);
            swayPos.y = THREE.MathUtils.lerp(swayPos.y, 0, delta * 10);

            const speedMagnitude = new THREE.Vector2(velocity.x, velocity.z).length();
            let bobX = 0, bobY = 0;
            if (isGrounded && speedMagnitude > 0.1) {
                bobTimer += delta * 15; 
                bobX = Math.cos(bobTimer) * 0.005;
                bobY = Math.sin(bobTimer * 2) * 0.005;
            } else {
                bobTimer = 0;
            }

            if (activeWeapon === 'rifle') {
                if (!isReloading) {
                    rifleGroup.position.set(
                        weaponBasePos.x + swayPos.x + bobX,
                        weaponBasePos.y + swayPos.y + bobY + drawOffset,
                        weaponBasePos.z
                    );
                    if (isInspecting) {
                        inspectTimer += delta;
                        rifleGroup.rotation.y = THREE.MathUtils.lerp(0, 0.5, Math.sin(inspectTimer * 2));
                        rifleGroup.rotation.z = THREE.MathUtils.lerp(0, 0.3, Math.sin(inspectTimer * 2));
                    } else {
                        rifleGroup.rotation.x = THREE.MathUtils.lerp(rifleGroup.rotation.x, 0, delta * 10);
                        rifleGroup.rotation.y = THREE.MathUtils.lerp(rifleGroup.rotation.y, 0, delta * 10);
                        rifleGroup.rotation.z = THREE.MathUtils.lerp(rifleGroup.rotation.z, 0, delta * 10);
                    }
                }
                if (muzzleLight.intensity > 0) muzzleLight.intensity -= delta * 30;
                if (isFiring && time - lastFireTime > FIRE_RATE) {
                    fireRifle();
                    lastFireTime = time;
                }
                currentSpread = THREE.MathUtils.lerp(currentSpread, 0, delta * 5);
            
            } else if (activeWeapon === 'knife') {
                let targetPos = knifeBasePos.clone();
                let targetRot = new THREE.Euler(0, 0, 0);

                if (isAttackingKnife) {
                    knifeAttackTimer += delta;
                    const slashDuration = 0.35;
                    const progress = knifeAttackTimer / slashDuration;
                    
                    if (progress < 0.2) {
                         targetPos.x += 0.15;
                         targetPos.y += 0.15;
                         targetRot.z = -0.5; 
                         targetRot.y = -0.3;
                    } else if (progress < 0.6) {
                        targetPos.x -= 0.4; 
                        targetPos.y -= 0.1;
                        targetPos.z -= 0.3; 
                        
                        targetRot.z = 1.2; 
                        targetRot.x = -0.4;
                        targetRot.y = 0.8;
                    }
                    if (knifeAttackTimer > slashDuration) isAttackingKnife = false;
                } 
                else if (isInspecting) {
                    inspectTimer += delta;
                    if (inspectTimer < 0.4) {
                        const t = inspectTimer / 0.4;
                        targetRot.z = Math.PI * 2 * t; 
                        targetRot.x = -Math.PI * 0.3 * Math.sin(t * Math.PI); 
                    } else {
                        const t = inspectTimer - 0.4;
                        targetPos.x = 0.0; 
                        targetPos.y = -0.25;
                        targetRot.z = 0.6; 
                        targetRot.y = 0.4 + Math.cos(t * 1.5) * 0.15; 
                        targetRot.x = 0.2 + Math.sin(t * 2) * 0.05; 
                    }
                }

                const smooth = delta * 15;
                knifeGroup.position.set(
                    THREE.MathUtils.lerp(knifeGroup.position.x, targetPos.x + swayPos.x + bobX, smooth),
                    THREE.MathUtils.lerp(knifeGroup.position.y, targetPos.y + swayPos.y + bobY + drawOffset, smooth),
                    THREE.MathUtils.lerp(knifeGroup.position.z, targetPos.z, smooth)
                );
                
                knifeGroup.rotation.x = THREE.MathUtils.lerp(knifeGroup.rotation.x, targetRot.x, smooth);
                knifeGroup.rotation.y = THREE.MathUtils.lerp(knifeGroup.rotation.y, targetRot.y, smooth);
                knifeGroup.rotation.z = THREE.MathUtils.lerp(knifeGroup.rotation.z, targetRot.z, smooth);
            }

            updateCrosshair(velocity);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
